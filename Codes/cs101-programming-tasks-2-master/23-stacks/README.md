* [К оглавлению задачника](https://github.com/urfu-code/cs101-main)
* [Кодекс разработчика](https://docs.google.com/document/d/1w8C1VyDPh9_1DaGD6oDJWmHw8V6cWrr469CgMiLGmdE/edit#)

# Задачи на использование стека

Отныне сдавать задачи нужно в [специальный контест](http://acm.timus.ru/auth.aspx?source=monitor.aspx%3fid=204).
Подробности см. в группе https://vk.com/basicprogramming

На этой неделе — это задачи E и F, каждая оценивается по 2 балла.

Не забывайте проверять стиль написанного вами кода с помощью [Code Stylist](https://labs.skbkontur.ru/cleancode).


# Подсказки

**Внимание!** 

Вы не обязаны решать задачи в точности следуя указаниям ниже.
Более того, будет лучше, если у вас получится решить задачу без использования этих подсказок.

Рекомендуется пользоваться этим подсказками, только если совсем не можете самостоятельно придумать как решать задачу.

Впрочем, если вы уже решили задачу, будет небесполезно подсказки все же прочитать.
Возможно, они откроют вам какой-то новый взгляд на задачу.

↓

↓

↓

↓

↓

↓

↓

↓

↓

↓


## Задача E. Монобильярд

http://acm.timus.ru/problem.aspx?num=1494

Эта задача нужна, чтобы освоиться со структурой данных Стек.

Бильярдная луза ведет себя в точности как стек. Чичиков выполняет операцию Push, а Ревизор — операцию Pop.

Можно, предположив, что Чичиков играет по правилам, попробовать повторить последовательность операций Push и Pop,
воспроизводящую игру. Если это сделать не получится, значит Чичиков читер!

_Попробуйте в этом месте остановиться и попытаться самостоятельно додумать алгоритм._

Пусть Чичиков уже сделал несколько ударов, а Ревизор уже достал несколько шаров.
Глядя на верхний шар в лузе и зная, какой шар Ревизор должен достать следующий, можно понять,
какая операция должна случиться следующей: если в лузе тот шар, который Ревизору доставать следующим — пора делать Pop, 
иначе — Push.

Осталось оформить эту идею в виде кода.

## Задача F. CSV

http://acm.timus.ru/problem.aspx?num=1992

Во многих программах есть операции отмены последних действий и повтора последних отмененных действий.
Так что техника работы с клонами не пустая выдумка, а очень даже часто встречается в реальных задачах. :-)

Состояние каждого клона можно описать двумя стеками: стек основенных пограмм и стек отмененных программ.
Все описанные в задаче операции просто оперируют с этими стеками.

Вам будет удобнее, если вы введете отдельный класс `Clone`, в котором будете хранить эти стеки.
Тогда операции удобно будет сделать методами этого класса.

Есть один нюанс реализации.
Для эффективной работы операции клонирования нужно использовать стек, реализованный на связных списках 
(см. материалы с соответствующей лекции).

Кстати, название задачи — это аллюзия на систему контроля версий CVS (concurrent versions system) — предшественницы svn и git.
